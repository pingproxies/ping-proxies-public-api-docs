---
title: "Exporting a list of proxies from a particular service"
description: "Learn how to export a formatted list of proxies from a specific service using the list_by_search endpoint"
icon: "file-export"
---

This example demonstrates how to export a formatted list of proxies from a specific service using the `list_by_search` endpoint with filtering parameters. Unlike the basic search, this endpoint returns ready-to-use proxy strings in various formats (standard, HTTP, SOCKS5, SOCKS5H).

<CodeGroup>
```python Python
import requests
import os
from datetime import datetime

# API credentials
API_PUBLIC_KEY = "your_public_key"
API_PRIVATE_KEY = "your_private_key"
BASE_URL = "https://api.pingproxies.com/1.0/public"

# Headers for authentication
headers = {
    "X-API-Public-Key": API_PUBLIC_KEY,
    "X-API-Private-Key": API_PRIVATE_KEY
}

def export_service_proxies(service_id, format_type="standard", protocol="http"):
    """
    Export a formatted list of proxies from a specific service.
    
    Args:
        service_id: ID of the service to export proxies from
        format_type: Format of the returned proxies ("standard", "http", "socks5", "socks5h")
        protocol: Protocol to use ("http" or "socks5")
        
    Returns:
        List of formatted proxy strings
    """
    # Set up the parameters for list_by_search
    params = {
        "service_id": service_id,
        "list_format": format_type,     # Format of the returned proxies
        "list_protocol": protocol,      # Protocol to use
        "list_version": "ipv4",         # IP version
        "list_authentication": "username_and_password"  # Authentication type
    }
    
    # Make request to the list_by_search endpoint
    response = requests.get(
        f"{BASE_URL}/user/proxy/list_by_search",
        params=params,
        headers=headers
    )
    
    if response.status_code != 200:
        print(f"Error: {response.status_code}")
        print(response.text)
        return []
    
    data = response.json()
    
    # The list endpoint returns the formatted proxies directly in data
    proxy_list = data["data"]
    
    print(f"Successfully retrieved {len(proxy_list)} formatted proxies from service {service_id}")
    return proxy_list

def export_to_file(proxy_list, service_id, format_type="standard"):
    """Export proxy list to a file."""
    # Create a default filename with timestamp
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    filename = f"service_{service_id}_proxies_{format_type}_{timestamp}.txt"
    
    # Write the proxy list to a file
    with open(filename, "w") as file:
        for proxy in proxy_list:
            file.write(f"{proxy}\n")
    
    print(f"Exported {len(proxy_list)} proxies to {filename}")
    return filename

# Example usage
if __name__ == "__main__":
    # Replace with your actual service ID
    SERVICE_ID = "API-1234-5678"
    
    # Get proxies in different formats
    standard_list = export_service_proxies(SERVICE_ID, "standard", "http")
    http_list = export_service_proxies(SERVICE_ID, "http", "http")
    socks5_list = export_service_proxies(SERVICE_ID, "socks5", "socks5")
    
    # Export to files
    if standard_list:
        export_to_file(standard_list, SERVICE_ID, "standard")
    if http_list:
        export_to_file(http_list, SERVICE_ID, "http")
    if socks5_list:
        export_to_file(socks5_list, SERVICE_ID, "socks5")
    
    # Print sample of each format
    print("\nSample outputs:")
    if standard_list:
        print(f"Standard format: {standard_list[0]}")
    if http_list:
        print(f"HTTP format: {http_list[0]}")
    if socks5_list:
        print(f"SOCKS5 format: {socks5_list[0]}")
```

```javascript JavaScript
// API credentials
const API_PUBLIC_KEY = 'your_public_key';
const API_PRIVATE_KEY = 'your_private_key';
const BASE_URL = 'https://api.pingproxies.com/1.0/public';

/**
 * Export a formatted list of proxies from a specific service
 * @param {string} serviceId - ID of the service to export proxies from
 * @param {string} formatType - Format of the returned proxies
 * @param {string} protocol - Protocol to use
 * @returns {Promise<Array>} List of formatted proxy strings
 */
async function exportServiceProxies(serviceId, formatType = 'standard', protocol = 'http') {
  // Set up the parameters for list_by_search
  const url = new URL(`${BASE_URL}/user/proxy/list_by_search`);
  const params = {
    'service_id': serviceId,
    'list_format': formatType,    // Format of the returned proxies
    'list_protocol': protocol,    // Protocol to use
    'list_version': 'ipv4',       // IP version
    'list_authentication': 'username_and_password'  // Authentication type
  };
  
  // Add all params to URL
  Object.keys(params).forEach(key => 
    url.searchParams.append(key, params[key])
  );
  
  try {
    const response = await fetch(url, {
      headers: {
        'X-API-Public-Key': API_PUBLIC_KEY,
        'X-API-Private-Key': API_PRIVATE_KEY
      }
    });
    
    if (!response.ok) {
      throw new Error(`HTTP error! Status: ${response.status}`);
    }
    
    const data = await response.json();
    
    // The list endpoint returns the formatted proxies directly in data
    const proxyList = data.data;
    
    console.log(`Successfully retrieved ${proxyList.length} formatted proxies from service ${serviceId}`);
    return proxyList;
    
  } catch (error) {
    console.error('Error retrieving proxy list:', error);
    return [];
  }
}

/**
 * Export proxy list to a file
 * @param {Array} proxyList - List of proxy strings
 * @param {string} serviceId - Service ID for file naming
 * @param {string} formatType - Format of the proxies
 * @returns {string} Filename of the exported file
 */
function exportToFile(proxyList, serviceId, formatType = 'standard') {
  // In browser context, create a download
  if (typeof window !== 'undefined') {
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const filename = `service_${serviceId}_proxies_${formatType}_${timestamp}.txt`;
    
    // Create a blob with the proxy list
    const content = proxyList.join('\n');
    const blob = new Blob([content], { type: 'text/plain' });
    
    // Create a download link and trigger it
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    
    // Clean up
    setTimeout(() => {
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }, 0);
    
    console.log(`Exported ${proxyList.length} proxies to ${filename}`);
    return filename;
  } 
  // In Node.js context, use fs
  else if (typeof require !== 'undefined') {
    const fs = require('fs');
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const filename = `service_${serviceId}_proxies_${formatType}_${timestamp}.txt`;
    
    fs.writeFileSync(filename, proxyList.join('\n'));
    
    console.log(`Exported ${proxyList.length} proxies to ${filename}`);
    return filename;
  }
  else {
    console.log('Unable to export file in current environment');
    return null;
  }
}

// Example usage in Node.js
async function main() {
  // Replace with your actual service ID
  const SERVICE_ID = 'API-1234-5678';
  
  // Get proxies in different formats
  const standardList = await exportServiceProxies(SERVICE_ID, 'standard', 'http');
  const httpList = await exportServiceProxies(SERVICE_ID, 'http', 'http');
  const socks5List = await exportServiceProxies(SERVICE_ID, 'socks5', 'socks5');
  
  // Export to files
  if (standardList.length > 0) {
    exportToFile(standardList, SERVICE_ID, 'standard');
  }
  if (httpList.length > 0) {
    exportToFile(httpList, SERVICE_ID, 'http');
  }
  if (socks5List.length > 0) {
    exportToFile(socks5List, SERVICE_ID, 'socks5');
  }
  
  // Print sample of each format
  console.log('\nSample outputs:');
  if (standardList.length > 0) {
    console.log(`Standard format: ${standardList[0]}`);
  }
  if (httpList.length > 0) {
    console.log(`HTTP format: ${httpList[0]}`);
  }
  if (socks5List.length > 0) {
    console.log(`SOCKS5 format: ${socks5List[0]}`);
  }
}

// Run the example if in Node.js
if (typeof window === 'undefined') {
  main().catch(console.error);
}
```

```php PHP
<?php
// API credentials
$apiPublicKey = 'your_public_key';
$apiPrivateKey = 'your_private_key';
$baseUrl = 'https://api.pingproxies.com/1.0/public';

/**
 * Export a formatted list of proxies from a specific service
 * 
 * @param string $apiPublicKey API public key
 * @param string $apiPrivateKey API private key
 * @param string $baseUrl API base URL
 * @param string $serviceId ID of the service to export proxies from
 * @param string $formatType Format of the returned proxies
 * @param string $protocol Protocol to use
 * @return array List of formatted proxy strings
 */
function exportServiceProxies($apiPublicKey, $apiPrivateKey, $baseUrl, $serviceId, $formatType = 'standard', $protocol = 'http') {
    // Headers for authentication
    $headers = [
        'X-API-Public-Key: ' . $apiPublicKey,
        'X-API-Private-Key: ' . $apiPrivateKey
    ];
    
    // Set up the parameters for list_by_search
    $params = [
        'service_id' => $serviceId,
        'list_format' => $formatType,     // Format of the returned proxies
        'list_protocol' => $protocol,      // Protocol to use
        'list_version' => 'ipv4',         // IP version
        'list_authentication' => 'username_and_password'  // Authentication type
    ];
    
    // Build query string
    $queryString = http_build_query($params);
    
    // Make request to the list_by_search endpoint
    $ch = curl_init($baseUrl . '/user/proxy/list_by_search?' . $queryString);
    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
    curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);
    
    $response = curl_exec($ch);
    $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);
    curl_close($ch);
    
    if ($httpCode !== 200) {
        echo "Error: " . $httpCode . "\n";
        echo $response . "\n";
        return [];
    }
    
    $data = json_decode($response, true);
    
    // The list endpoint returns the formatted proxies directly in data
    $proxyList = $data['data'];
    
    echo "Successfully retrieved " . count($proxyList) . " formatted proxies from service {$serviceId}\n";
    return $proxyList;
}

/**
 * Export proxy list to a file
 * 
 * @param array $proxyList List of proxy strings
 * @param string $serviceId Service ID for file naming
 * @param string $formatType Format of the proxies
 * @return string Filename of the exported file
 */
function exportToFile($proxyList, $serviceId, $formatType = 'standard') {
    // Create a default filename with timestamp
    $timestamp = date('Ymd_His');
    $filename = "service_{$serviceId}_proxies_{$formatType}_{$timestamp}.txt";
    
    // Write the proxy list to a file
    $file = fopen($filename, "w");
    foreach ($proxyList as $proxy) {
        fwrite($file, $proxy . "\n");
    }
    fclose($file);
    
    echo "Exported " . count($proxyList) . " proxies to {$filename}\n";
    return $filename;
}

// Example usage
// Replace with your actual service ID
$serviceId = 'API-1234-5678';

// Get proxies in different formats
$standardList = exportServiceProxies($apiPublicKey, $apiPrivateKey, $baseUrl, $serviceId, 'standard', 'http');
$httpList = exportServiceProxies($apiPublicKey, $apiPrivateKey, $baseUrl, $serviceId, 'http', 'http');
$socks5List = exportServiceProxies($apiPublicKey, $apiPrivateKey, $baseUrl, $serviceId, 'socks5', 'socks5');

// Export to files
if (!empty($standardList)) {
    exportToFile($standardList, $serviceId, 'standard');
}
if (!empty($httpList)) {
    exportToFile($httpList, $serviceId, 'http');
}
if (!empty($socks5List)) {
    exportToFile($socks5List, $serviceId, 'socks5');
}

// Print sample of each format
echo "\nSample outputs:\n";
if (!empty($standardList)) {
    echo "Standard format: " . $standardList[0] . "\n";
}
if (!empty($httpList)) {
    echo "HTTP format: " . $httpList[0] . "\n";
}
if (!empty($socks5List)) {
    echo "SOCKS5 format: " . $socks5List[0] . "\n";
}
?>
```

```go Go
package main

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"net/http"
	"net/url"
	"os"
	"time"
)

// API credentials
const (
	apiPublicKey  = "your_public_key"
	apiPrivateKey = "your_private_key"
	baseURL       = "https://api.pingproxies.com/1.0/public"
)

// ProxyListResponse holds the structure of the API list response
type ProxyListResponse struct {
	Data    []string `json:"data"`
	Message string   `json:"message"`
}

// ExportServiceProxies retrieves all proxies from a specific service in a formatted list
func ExportServiceProxies(serviceId, formatType, protocol string) ([]string, error) {
	// Create a new HTTP client
	client := &http.Client{}
	
	// Build the URL with query parameters
	baseEndpoint := fmt.Sprintf("%s/user/proxy/list_by_search", baseURL)
	u, err := url.Parse(baseEndpoint)
	if err != nil {
		return nil, err
	}
	
	q := u.Query()
	q.Add("service_id", serviceId)
	q.Add("list_format", formatType)     // Format of the returned proxies
	q.Add("list_protocol", protocol)     // Protocol to use
	q.Add("list_version", "ipv4")        // IP version
	q.Add("list_authentication", "username_and_password")  // Authentication type
	
	u.RawQuery = q.Encode()
	
	// Create the request
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, err
	}
	
	// Add authentication headers
	req.Header.Add("X-API-Public-Key", apiPublicKey)
	req.Header.Add("X-API-Private-Key", apiPrivateKey)
	
	// Execute the request
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	
	if resp.StatusCode != 200 {
		return nil, fmt.Errorf("error: %d", resp.StatusCode)
	}
	
	// Read and parse the response
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	
	var listResponse ProxyListResponse
	err = json.Unmarshal(body, &listResponse)
	if err != nil {
		return nil, err
	}
	
	fmt.Printf("Successfully retrieved %d formatted proxies from service %s\n", len(listResponse.Data), serviceId)
	return listResponse.Data, nil
}

// ExportToFile exports proxy list to a file
func ExportToFile(proxyList []string, serviceId, formatType string) (string, error) {
	// Create a default filename with timestamp
	timestamp := time.Now().Format("20060102_150405")
	filename := fmt.Sprintf("service_%s_proxies_%s_%s.txt", serviceId, formatType, timestamp)
	
	// Create file
	file, err := os.Create(filename)
	if err != nil {
		return "", err
	}
	defer file.Close()
	
	// Write each proxy on a new line
	for _, proxy := range proxyList {
		_, err := file.WriteString(proxy + "\n")
		if err != nil {
			return "", err
		}
	}
	
	fmt.Printf("Exported %d proxies to %s\n", len(proxyList), filename)
	return filename, nil
}

func main() {
	// Replace with your actual service ID
	serviceId := "API-1234-5678"
	
	// Get proxies in different formats
	standardList, err := ExportServiceProxies(serviceId, "standard", "http")
	if err != nil {
		fmt.Printf("Error retrieving standard proxies: %v\n", err)
	}
	
	httpList, err := ExportServiceProxies(serviceId, "http", "http")
	if err != nil {
		fmt.Printf("Error retrieving HTTP proxies: %v\n", err)
	}
	
	socks5List, err := ExportServiceProxies(serviceId, "socks5", "socks5")
	if err != nil {
		fmt.Printf("Error retrieving SOCKS5 proxies: %v\n", err)
	}
	
	// Export to files
	if len(standardList) > 0 {
		_, err := ExportToFile(standardList, serviceId, "standard")
		if err != nil {
			fmt.Printf("Error exporting standard proxies: %v\n", err)
		}
	}
	
	if len(httpList) > 0 {
		_, err := ExportToFile(httpList, serviceId, "http")
		if err != nil {
			fmt.Printf("Error exporting HTTP proxies: %v\n", err)
		}
	}
	
	if len(socks5List) > 0 {
		_, err := ExportToFile(socks5List, serviceId, "socks5")
		if err != nil {
			fmt.Printf("Error exporting SOCKS5 proxies: %v\n", err)
		}
	}
	
	// Print sample of each format
	fmt.Println("\nSample outputs:")
	if len(standardList) > 0 {
		fmt.Printf("Standard format: %s\n", standardList[0])
	}
	if len(httpList) > 0 {
		fmt.Printf("HTTP format: %s\n", httpList[0])
	}
	if len(socks5List) > 0 {
		fmt.Printf("SOCKS5 format: %s\n", socks5List[0])
	}
}
```

```java Java
import java.io.FileWriter;
import java.io.IOException;
import java.net.URI;
import java.net.URISyntaxException;
import java.net.URLEncoder;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.nio.charset.StandardCharsets;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.List;

import com.fasterxml.jackson.databind.ObjectMapper;

public class ExportServiceProxies {

    // API credentials
    private static final String API_PUBLIC_KEY = "your_public_key";
    private static final String API_PRIVATE_KEY = "your_private_key";
    private static final String BASE_URL = "https://api.pingproxies.com/1.0/public";
    
    private static final HttpClient client = HttpClient.newHttpClient();
    private static final ObjectMapper mapper = new ObjectMapper();
    
    // POJO for API response
    static class ProxyListResponse {
        public List<String> data;
        public String message;
    }
    
    /**
     * Export a formatted list of proxies from a specific service
     * @param serviceId ID of the service to export proxies from
     * @param formatType Format of the returned proxies
     * @param protocol Protocol to use
     * @return List of formatted proxy strings
     */
    public static List<String> exportServiceProxies(String serviceId, String formatType, String protocol) 
            throws IOException, InterruptedException, URISyntaxException {
        
        // Build the URI with query parameters
        String encodedServiceId = URLEncoder.encode(serviceId, StandardCharsets.UTF_8);
        String encodedFormat = URLEncoder.encode(formatType, StandardCharsets.UTF_8);
        String encodedProtocol = URLEncoder.encode(protocol, StandardCharsets.UTF_8);
        
        URI uri = new URI(String.format("%s/user/proxy/list_by_search", BASE_URL))
                .resolve("?service_id=" + encodedServiceId
                        + "&list_format=" + encodedFormat
                        + "&list_protocol=" + encodedProtocol
                        + "&list_version=ipv4"
                        + "&list_authentication=username_and_password");
        
        // Create the request
        HttpRequest request = HttpRequest.newBuilder()
                .uri(uri)
                .header("X-API-Public-Key", API_PUBLIC_KEY)
                .header("X-API-Private-Key", API_PRIVATE_KEY)
                .GET()
                .build();
        
        // Execute the request
        HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());
        
        if (response.statusCode() != 200) {
            throw new IOException("API request failed with status code: " + response.statusCode());
        }
        
        // Parse the response
        ProxyListResponse listResponse = mapper.readValue(response.body(), ProxyListResponse.class);
        
        System.out.printf("Successfully retrieved %d formatted proxies from service %s%n", 
                listResponse.data.size(), serviceId);
        return listResponse.data;
    }
    
    /**
     * Export proxy list to a file
     * @param proxyList List of proxy strings
     * @param serviceId Service ID for file naming
     * @param formatType Format of the proxies
     * @return Filename of the exported file
     */
    public static String exportToFile(List<String> proxyList, String serviceId, String formatType) 
            throws IOException {
        // Create a default filename with timestamp
        LocalDateTime now = LocalDateTime.now();
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyyMMdd_HHmmss");
        String timestamp = now.format(formatter);
        String filename = String.format("service_%s_proxies_%s_%s.txt", serviceId, formatType, timestamp);
        
        // Write the proxy list to a file
        try (FileWriter writer = new FileWriter(filename)) {
            for (String proxy : proxyList) {
                writer.write(proxy + "\n");
            }
        }
        
        System.out.printf("Exported %d proxies to %s%n", proxyList.size(), filename);
        return filename;
    }

    public static void main(String[] args) {
        try {
            // Replace with your actual service ID
            String serviceId = "API-1234-5678";
            
            // Get proxies in different formats
            List<String> standardList = exportServiceProxies(serviceId, "standard", "http");
            List<String> httpList = exportServiceProxies(serviceId, "http", "http");
            List<String> socks5List = exportServiceProxies(serviceId, "socks5", "socks5");
            
            // Export to files
            if (!standardList.isEmpty()) {
                exportToFile(standardList, serviceId, "standard");
            }
            if (!httpList.isEmpty()) {
                exportToFile(httpList, serviceId, "http");
            }
            if (!socks5List.isEmpty()) {
                exportToFile(socks5List, serviceId, "socks5");
            }
            
            // Print sample of each format
            System.out.println("\nSample outputs:");
            if (!standardList.isEmpty()) {
                System.out.println("Standard format: " + standardList.get(0));
            }
            if (!httpList.isEmpty()) {
                System.out.println("HTTP format: " + httpList.get(0));
            }
            if (!socks5List.isEmpty()) {
                System.out.println("SOCKS5 format: " + socks5List.get(0));
            }
        } catch (Exception e) {
            System.out.println("Error: " + e.getMessage());
            e.printStackTrace();
        }
    }
}
```
</CodeGroup>

## Understanding the List Formats

When exporting proxies, you can choose from several different formats:

| Format | Example | Description |
|--------|---------|-------------|
| `standard` | `123.456.78.90:8080` | Basic format with IP:port only |
| `http` | `http://username:password@123.456.78.90:8080` | HTTP proxy URL format |
| `socks5` | `socks5://username:password@123.456.78.90:1080` | SOCKS5 proxy URL format |
| `socks5h` | `socks5h://username:password@123.456.78.90:1080` | SOCKS5 with hostname resolution |

## Authentication Types

You can also specify the authentication method in your export:

- `username_and_password`: Standard authentication with proxy user credentials
- `ip_address`: IP-based authentication 
- `proxy_specific`: Proxy-specific authentication

## Use Cases

- **Web scraping tools**: Export proxy lists for tools like Scrapy, Selenium, or Puppeteer
- **Browser extensions**: Generate proxy configurations for proxy-switching extensions
- **Third-party integration**: Create formatted proxy lists for third-party applications
- **Team sharing**: Export proxy lists to share with team members

## Best Practices

1. **Proper formatting**: Choose the appropriate format based on your target application
2. **Regular exports**: Schedule regular exports to ensure you always have up-to-date proxy lists
3. **Service organization**: Organize proxies by service for better management
4. **Secure storage**: Store exported proxy lists securely as they contain authentication details