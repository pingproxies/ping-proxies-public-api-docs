import java.io.IOException;
import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CompletableFuture;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

import com.fasterxml.jackson.databind.ObjectMapper;

public class PingProxiesPagination {

    // API credentials
    private static final String API_PUBLIC_KEY = "your_public_key";
    private static final String API_PRIVATE_KEY = "your_private_key";
    private static final String BASE_URL = "https://api.pingproxies.com/1.0/public/user/proxy/search";
    
    private static final HttpClient client = HttpClient.newHttpClient();
    private static final ObjectMapper mapper = new ObjectMapper();
    
    // Response class to hold paginated data
    static class PaginatedResponse {
        public List<Map<String, Object>> data;
        public int item_count;
        public String message;
        public int page;
        public int per_page;
        public int total_count;
    }
    
    // Fetch a single page
    private static PaginatedResponse fetchPage(int page, int perPage) throws IOException, InterruptedException {
        HttpRequest request = HttpRequest.newBuilder()
                .uri(URI.create(BASE_URL + "?page=" + page + "&per_page=" + perPage))
                .header("X-API-Public-Key", API_PUBLIC_KEY)
                .header("X-API-Private-Key", API_PRIVATE_KEY)
                .GET()
                .build();
        
        HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());
        return mapper.readValue(response.body(), PaginatedResponse.class);
    }
    
    // Fetch a single page asynchronously
    private static CompletableFuture<PaginatedResponse> fetchPageAsync(int page, int perPage) {
        HttpRequest request = HttpRequest.newBuilder()
                .uri(URI.create(BASE_URL + "?page=" + page + "&per_page=" + perPage))
                .header("X-API-Public-Key", API_PUBLIC_KEY)
                .header("X-API-Private-Key", API_PRIVATE_KEY)
                .GET()
                .build();
        
        return client.sendAsync(request, HttpResponse.BodyHandlers.ofString())
                .thenApply(HttpResponse::body)
                .thenApply(body -> {
                    try {
                        return mapper.readValue(body, PaginatedResponse.class);
                    } catch (IOException e) {
                        throw new RuntimeException(e);
                    }
                });
    }
    
    // Sequential pagination
    public static List<Map<String, Object>> fetchAllPagesSequential() throws IOException, InterruptedException {
        int perPage = 100;
        List<Map<String, Object>> allItems = new ArrayList<>();
        
        // Get first page to determine total count
        PaginatedResponse firstPage = fetchPage(1, perPage);
        
        // Calculate total pages
        int totalCount = firstPage.total_count;
        int totalPages = (int) Math.ceil((double) totalCount / perPage);
        
        System.out.printf("Found %d items across %d pages%n", totalCount, totalPages);
        
        // Add first page results
        allItems.addAll(firstPage.data);
        
        // Fetch remaining pages
        for (int page = 2; page <= totalPages; page++) {
            System.out.printf("Fetching page %d of %d%n", page, totalPages);
            
            PaginatedResponse pageData = fetchPage(page, perPage);
            allItems.addAll(pageData.data);
        }
        
        return allItems;
    }
    
    // Parallel pagination
    public static List<Map<String, Object>> fetchAllPagesParallel() throws IOException, InterruptedException {
        int perPage = 100;
        
        // Get first page to determine total count
        PaginatedResponse firstPage = fetchPage(1, 1);
        
        // Calculate total pages
        int totalCount = firstPage.total_count;
        int totalPages = (int) Math.ceil((double) totalCount / perPage);
        
        System.out.printf("Found %d items across %d pages%n", totalCount, totalPages);
        
        // Create a list of futures for all pages
        List<CompletableFuture<PaginatedResponse>> pageFutures = 
                IntStream.rangeClosed(1, totalPages)
                        .mapToObj(page -> fetchPageAsync(page, perPage))
                        .collect(Collectors.toList());
        
        // Combine all futures into a single future that completes when all page requests are done
        CompletableFuture<Void> allFutures = CompletableFuture.allOf(
                pageFutures.toArray(new CompletableFuture[0])
        );
        
        // When all futures complete, collect all the items from all pages
        List<Map<String, Object>> allItems = allFutures.thenApply(v -> 
                pageFutures.stream()
                        .map(CompletableFuture::join)
                        .flatMap(response -> response.data.stream())
                        .collect(Collectors.toList())
        ).join();
        
        return allItems;
    }

    public static void main(String[] args) {
        try {
            // Choose which method to use
            // List<Map<String, Object>> allItems = fetchAllPagesSequential();
            List<Map<String, Object>> allItems = fetchAllPagesParallel();
            
            System.out.printf("Successfully fetched %d items%n", allItems.size());
            // Process your items here
        } catch (Exception e) {
            System.out.println("Error fetching paginated data: " + e.getMessage());
            e.printStackTrace();
        }
    }
}