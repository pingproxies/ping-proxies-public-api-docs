---
title: 'Code Examples'
description: 'Code examples of how to use Ping Proxies services using Python'
---

To help customers with debugging, Ping Proxies provides TCP and UDP servers for testing proxy connectivity.

Our two TCP servers, running on `demo.residential.pingproxies.com` act an echo server and as an IP address reporting service.
- GET requests to port 40000 will receive their IP address sent back to them. HTTP/1.1, HTTP/2 and HTTP/3 - both cleartext and protected by TLS - is supported.
- Any bytes sent to port 40001 will be echo'd back.

Our two UDP servers, runnong on `demo.residential.pingproxies.com` also act as an echo server and an IP address reporting service.
- Any bytes sent to port 50000 will receive their IP address in response.
- Any bytes sent to port 50001 will be echo'd back.



In our examples we use these servers as our end targets. Feel free to use them in your own code for testing your proxies.

<Note>
 - Python examples rely on implicit behaviours of modules to execute different proxying methods.
 - Rust examples are more explicit and show exactly how the mechanisms of proxying work.
</Note>

## SOCKS5
SOCKS proxies allow you to tunnel both TCP and UDP traffic, making them a very good choice for things like gaming or VOIP (Voice over IP).

<Accordion title = "SOCKS5 TCP">
<Tabs>
	<Tab title="Python">
		```python main.py
		import requests

		USER = "..."
		PASS = "..."

		PROXY = "residential.pingproxies.com"
		PORT = 8123

		PROXY_STRING = f"socks5://{USER}:{PASS}@{PROXY}:{PORT}"
		PROXIES = {"http": PROXY_STRING, "https": PROXY_STRING}

		TARGET = "https://demo.residential.pingproxies.com:40000"

		def main():
		    resp = requests.get(TARGET, proxies=PROXIES)
		```

		`requests` allows us to quickly establish a SOCKS5 connection and send a HTTP request over it.

		<Note>
			Install `requests` with `pip install -U 'requests[socks]'`
		</Note>
	</Tab>

 	<Tab title="Rust">
		```rust main.rs
		// tokio = { version = "1", features = ["full"] }
		// reqwest = { version = "0.12", features = ["socks"] }

		const USER: &str = "...";
		const PASS: &str = "...";

		const PROXY: &str = "residential.pingproxies.com"
		const PORT: u16 = 8123;

		const TARGET: &str = "https://demo.residential.pingproxies.com:40000";

		#[tokio::main]
		async fn main() {
		    let proxy_string = format!("{USER}:{PASS}@{PROXY}:{PORT}");
		    let proxy = reqwest::Proxy::all(proxy_string).expect("proxy failed to build");

		    let client = reqwest::Client::builder()
		        .proxy(proxy)
		        .build()
		        .expect("failed to build reqwest client");

		    let res = client
		        .get(TARGET)
		        .send()
		        .await
		        .expect("failed sending/receiving request/resposne");

		    let status = res.status();
		    let body = res.text().await.expect("failed to read body");

		    println!("Status: {status}");
		    println!("{body}");
		}
		```

		There are many ways to proxy TCP using SOCKS5 in Rust. The example above uses `Reqwest`, Rust's most popular high-level HTTP client.

		<Note>
			The SOCKS5 proxy connector in `Reqwest` was actually created by us in an effort to contribtue back to the open source community.
		</Note>
	</Tab>
</Tabs>
</Accordion>


<Accordion title = "SOCKS5 UDP">
For our UDP examples, we use the PingProxies UDP test server. This server, open and free to everyone, returns the IP addresss of any connection formed with it.

<Tabs>
	<Tab title="Python">
		```python main.py
		USER = "..."
		PASS = "..."

		PROXY = "residential.pingproxies.com"
		PORT = 8123

		PROXY_STRING = f"socks5://{USER}:{PASS}@{PROXY}:{PORT}"

		# Ping Proxies UDP-based IP reporting server
		TARGET_URI = "demo.residential.pingproxies.com"
		TARGET_PORT = 50000

		def main():
		    # Bind UDP Socket
		    ss = socks.socksocket(socket.AF_INET, socket.SOCK_DGRAM)

		    # Proxy all datagrams through Ping Proxies UDP proxy
		    ss.set_proxy(socks.SOCKS5, PROXY_URI, PROXY_PORT, False, USER, PASS)

		    # Send a byte to the server and receive our IP address back
		    ss.sendto(bytes(0x00), (TARGET_URI, TARGET_PORT))
		    (ip, _) = ss.recvfrom(16)

		```

		For SOCKS UDP proxying we rely on `PySocks`, which provides an API like that of the `socket` module, except the data sent on the socket gets proxied.

		<Note>
		`PySocks` has a bug and performs UDP proxying slightly wrong - a result of them misunderstanding the  RFC. If you change the `False` to `True`, this will cause proxying to fail even though it should work fine. We have a PR to `PySocks` submitted and waiting to be merged.
		</Note>
	</Tab>

	<Tab title="Rust">
		```rust main.rs
		[tokio::main]
		fn main() {
			println!("Hello World!")
		}
		```
	</Tab>
</Tabs>
</Accordion>


## HTTP
HTTP proxies can either tunnel TPC traffic, or HTTP request. They do this by using the CONNECT method for  establishing TCP tunnels or acting as a man in the middle, directly forwarding any non-CONNECT requests it receives.

<Accordion title = "HTTP/1.1">
	<Accordion title = "HTTP/1.1 CONNECT">
	The CONNECT method is very simple. Simply send your target destination and proxy credentials to the proxy server in a request using the CONNECT method. The proxy server will establish a tunnel to that target server, send you a 200 OK telling you the proxy tunnel has been established, then blindly funnel bytes between you and your target.

	<Tabs>
		<Tab title="Python">
			```python main.py
			import requests

			USER = "..."
			PASS = "..."

			PROXY = "residential.pingproxies.com"
			PORT = 8123

			PROXY_STRING = f"socks5://{USER}:{PASS}@{PROXY}:{PORT}"
			PROXIES = {"http": PROXY_STRING, "https": PROXY_STRING}

			TARGET = "https://demo.residential.pingproxies.com:40000"

			def main():
			    resp = requests.get(TARGET, proxies=PROXIES)
			```

			`requests` lets us quickly establish a proxy connection and send a HTTP request over it. Any proxy request to a HTTPS target will use a CONNECT to establish the proxy tunnel.
		</Tab>

		<Tab title="Rust">
		
			```rust main.rs
			// ureq = "3"

			const USER: &str = "...";
			const PASS: &str = "...";

			const PROXY: &str = "residential.pingproxies.com";
			const PORT: u16 = 8123;

			const TARGET: &str = "https://demo.residential.pingproxies.com:40000";

			fn main() {
			    let proxy = ureq::Proxy::builder(ureq::ProxyProtocol::Http)
			        .username(USER)
			        .password(PASS)
			        .host(PROXY)
			        .port(PORT)
			        .build()
			        .expect("failed to build proxy");

			    let agent = ureq::Agent::config_builder()
			        .proxy(Some(proxy))
			        .build()
			        .new_agent();

			    let res = agent
			        .get(TARGET)
			        .call()
			        .expect("failed sending/receiving request/response");

			    let status = res.status();
			    let body = res
			        .into_body()
			        .read_to_string()
			        .expect("failed to read body");

			    println!("Status: {status}");
			    println!("{body}");
			}
			```
			This example uses `ureq`, a syncrhonous library. For an async client, slightly modify the SOCKS TCP example.

			<Note>
				The CONNECT proxying logic underlying `ureq` (`ureq-proto`) was actually written by us to bring the library in-line with the RFC and ensure maximum compatability.
			</Note>
		</Tab>
	</Tabs>
	</Accordion>

	<Accordion title = "HTTP/1.1 MITM">
	MITM proxying is even simpler than the CONNECT method. Simply send your request directly to the server and it will forward it for you. Unfortunately, the  simplicity of MITM proxying is offset by security risks as you can no longer perform _TLS to the Target_ to encryp your data  and hide it from anyone listening and even the proxy server itself.
	<Tabs>
		<Tab title="Python">
			```python main.py
				import requests

				PROXY_STRING = f"http://{USER}:{PASS}@residential.pingproxies.com:8123"
				PROXIES = {"http": PROXY_STRING, "https": PROXY_STRING}

				TARGET = "https://demo.residential.pingproxies.com:40000"

				def main():
				    resp = requests.get(TARGET, proxies=PROXIES)
			```

			`requests` lets us quickly establish a proxy connection and send a HTTP request over it. Any proxy request to a HTTP target will use MITM-style proxy requests.
		</Tab>

		<Tab title="Rust">
			```rust main.rs
			[tokio::main]
			fn main() {
				println!("Hello World!")
			}
			```		
		</Tab>
	</Tabs>
	</Accordion>
</Accordion>


<Accordion title = "HTTP/2">
HTTP/2 offers many advantages over HTTP/1.1. You can read about (or watch) these advantages in our blog _here_. To summarise however, HTTP/2 lets  you send multiple requests over the same connection, concurrently. Alllowing greater throughput with lower overhead.

You can't just speak HTTP/2 with a server, as not all servers support it. Fortunately, there exist three methods turning a TCP connection into a HTTP/2 connection:

- Prior Knowledge. Just asssume it speaks HTTP/2.
- HTTP/1.1 Ugprade. Speak HTTP/1 to the server and ask it to do HTTP/2.
- ALPN. When doing the TLS handshake, ask the server what protocols it supports.

On our services, we support Prior Knowledge and ALPN. The examples below show how to use both methods.

	<Accordion title = "HTTP/2 CONNECT">
	CONNECTs with HTTP/2 work just the same as in HTTP/1.1, except you can send multiple of them over the same connection at the same time. In this example, we use ALPN to upgrade our connection to HTTP/2 and send a HTTP/2 CONNECT.
	<Tabs>
		<Tab title="Python">
			```python main.py
			import httpx

			PROXY_STRING = f"https://{USER}:{PASS}@residential.pingproxies.com:8123"

			TARGET1 = "https://demo.residential.pingproxies.com:40000"
			TARGET2 = "https://demo.residential.pingproxies.com:40001"
			TARGET3 = "https://demo.residential.pingproxies.com:40002"

			def main():
				# Three requests will all use the same TCP connection to the proxy thanks to ALPN and HTTP/2
			    with httpx.Client(proxy=PROXY_STRING) as client:
			        resp = client.get(TARGET1, proxy=PROXY_STRING)
			        resp = client.get(TARGET2, proxy=PROXY_STRING)
			        resp = client.get(TARGET3, proxy=PROXY_STRING)
			```

			`httpx` is a more modern and feature-rich HTTP library. Unlike `requests`, it supports versions other than HTTP/1.1 and will use ALPN  to upgrade requests (including those to a proxy) where possible.

			By re-using a `httpx.Client`, the underlying TCP connection to the proxy server is kept for each client. As such, sending three requests requries only 4 TCP connections to be made. If this was done using HTTP/1.1, 6 TCP connections would need to be made (three to the proxy, three to the targets).
		</Tab>

		<Tab title="Rust">
			```rust main.rs
			[tokio::main]
			fn main() {
				println!("Hello World!")
			}
			```		
		</Tab>
	</Tabs>
	</Accordion>

	<Accordion title = "HTTP/2 MITM">
	<Tabs>
		<Tab title="Python">
			```python main.py
			import httpx

			PROXY_STRING = f"https://{USER}:{PASS}@residential.pingproxies.com:8123"

			TARGET1 = "https://demo.residential.pingproxies.com:40000"
			TARGET2 = "https://demo.residential.pingproxies.com:40001"
			TARGET3 = "https://demo.residential.pingproxies.com:40002"

			def main():
			    with httpx.Client(proxy=PROXY_STRING) as client:
			        resp = client.get(TARGET1, proxy=PROXY_STRING)
			        resp = client.get(TARGET2, proxy=PROXY_STRING)
			        resp = client.get(TARGET3, proxy=PROXY_STRING)
			```

			As with HTTP/1.1, any requests to a HTTP target will be sent MITM-style. The connection is re-used, just as  it is in the HTTP/2 CONNECT example.
		</Tab>

		<Tab title="Rust">
			```rust main.rs
			[tokio::main]
			fn main() {
				println!("Hello World!")
			}
			```		
		</Tab>
	</Tabs>
	</Accordion>
</Accordion>

<Accordion title = "HTTP/3">
The CONNECT method, even when used with HTTP/3 proxies which operate over UDP and QUIC, still establishes a TCP connection to the target. If you wish to establish UDP proxy connection using HTTP/3 "connection" to the target, you need to use the as-yet unsupported (by everyone, everywhere) CONNECT-UDP method. Alternatively, using SOCKS5 UDP.

This means that there is currently no way to use HTTP/3 to establish a tunnel over which you can send HTTP/3 traffic. MITM-style porxying does allow you to  send HTTP/3 requests to your end target however.

	<Accordion title = "HTTP/3 CONNECT">
	<Tabs>
		<Tab title="Python">
			```python main.py
			def main():
				print("Hello World!")
			```
		</Tab>

		<Tab title="Rust">
			```rust main.rs
			[tokio::main]
			fn main() {
				println!("Hello World!")
			}
			```		
		</Tab>
	</Tabs>
	</Accordion>

	<Accordion title = "HTTP/3 MITM">
	<Tabs>
		<Tab title="Python">
			```python main.py
			def main():
				print("Hello World!")
			```
		</Tab>

		<Tab title="Rust">
			```rust main.rs
			[tokio::main]
			fn main() {
				println!("Hello World!")
			}
			```		
		</Tab>
	</Tabs>
	</Accordion>
</Accordion>

## HTTP/3 over SOCKS5 UDP - Controlling Your Fingerprint
When using a MITM style proxy, the proxy server is responsible for performing the TLS handshake with the target. As such, you end up with a TLS fingerprint (JA3/JA4) that might not be ideal for your use-case. Until the CONNECT-UDP method is added to our network (or other  providers) the best solution is to proxy your HTTP/3 traffic over a SOCKS5 UDP proxy. The example below illustrates how you might do this.




